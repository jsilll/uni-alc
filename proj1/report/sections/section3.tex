\subsection{Choice of Solver}

The Automatic Placement of Rulesets problem involves intricate dependencies and memory constraints. For this reason, choosing the right solver was critical to the project's success. We chose to formulate the problem as a MaxSAT instance because these solvers excel in managing optimization problems, allowing for a formulation of the objective functions through weighted clauses.

MaxSAT is an optimization version of the Boolean Satisfiability problem (SAT). In contrast to SAT, MaxSAT seeks an assignment that satisfies the maximum number of clauses. In MaxSAT, clauses are divided into two categories:

\begin{enumerate}
    \item \textbf{Hard Clauses:} Mandatory constraints that must be satisfied for a solution to be valid. They represent non-negotiable requirements and ensure the fundamental feasibility of the solution. In our problem, all the constraints, except for the minimization of re-circulations, were considered hard clauses.

    \item \textbf{Soft Clauses:} Optional constraints that contribute to the optimization objective. They represent preferences or desires in the problem. Satisfying soft clauses enhances the solution's quality but is not obligatory for validity. The solver's job is to find an assignment that optimizes the total weight of satisfied soft clauses which, in our case, was the minimization of re-circulations.
\end{enumerate}

To conclude, MaxSAT's ability to handle both mandatory and optimality constraints, makes it the superior choice for complex problems like the Automatic Placement of Rulesets. After some experimentation, we decided to use RC2 solver.

\subsection{Encoding of the Problem}

Below, we delineate the key aspects of our encoding:

\begin{enumerate}
    \item \textbf{Switches Placement:} To represent the placement of switches, we introduced variables \(sw[i][j]\), that are true if switch \(i\) is placed in position \(j\).

    \item \textbf{Groups Placement:} To represent the placement of groups, we introduced variables \(gr[i][j][k]\), that are true if group \(k\) is placed in stage \(j\) of switch \(i\).

    \item \textbf{Uniqueness Constraints:} Constraints were formulated to ensure that each switch and group of rules was placed exactly once. Utilizing cardinality encoding, we imposed uniqueness properties on the variables \(sw\) and \(gr\). This was accomplished through the use of the \texttt{CardEnc.equals} method with a cardinality of 1. Moreover, an additional set of cardinality constraints is needed to ensure that only one switch is placed in each position. This was achieved through the use of the \texttt{CardEnc.atmost} method with a cardinality of 1.

    \item \textbf{Memory Limit Compliance:} Constraints were devised to ensure that the total memory requirements of all groups within each stage did not exceed the stage's memory capacity. Employing Pseudo-Boolean Encodings through the use of \texttt{PBEnc.atmost} method, we formulated constraints that ensure that the sum of memory requirements of the groups in each stage does not surpass that stage's memory limit.

    \item \textbf{Dependency Handling:} Dependencies between groups need to be handled in order to prevent re-circulations between switches. For each pair \((i, j)\) where \(j\) depends on \(i\), specific conditions were established. Auxiliary boolean variables \(besw[i][j]\) were introduced, indicating whether switch \(i\) is behind switch \(j\). By formulating clauses envolving these variables, we ensured that switches dependent on one another should not be placed in positions occurring before the positions of their dependencies.

    \item \textbf{Re-circulations:} To minimize re-circulations, another set of auxiliary boolean variables \(begr[i][j]\) were introduced, signifying whether group \(j\) was behind group \(i\). By formulating clauses envolving these variables, for each pair \((i, j)\) where \(j\) depends on \(i\), we ensured that groups dependent on one another should not be placed in stages occurring before the stages of their dependencies.
\end{enumerate}

Through this encoding of constraints, we transformed the problem into a series of boolean variables and logical relationships. The resulting formula encapsulated the essence of the problem, enabling sophisticated solvers like RC2 to explore the solution space efficiently.