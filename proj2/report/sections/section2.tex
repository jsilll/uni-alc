The implementation of the rulesets occurs within the framework of programmable switches, utilizing the Protocol Independent Switch Architecture (PISA). Within this architecture, incoming packets traverse through a parser, responsible for dissecting the packet's header fields. Subsequently, the packet progresses through the match+action pipeline, which consists of distinct stages. Each stage is a logically independent unit, capable of hosting multiple groups of rules. Stages impose limitations on the number of groups of rules they can accommodate based on available resources.

When a packet enters the pipeline, it follows a linear progression from one stage to the next. Each stage permits only one table lookup, a restriction that ensures robust performance guarantees but limits the system's programmability. While a packet cannot revert to a previous stage, it can be redirected back to the beginning of the pipeline, a process known as \textit{re-circulation}. However, this comes at the expense of performance: the more re-circulations a packet undergoes, the lower the network's efficiency. In the absence of re-circulations, the system operates at its peak performance, commonly referred to as line-rate.

The fundamental challenge addressed in this project revolves around the efficient allocation of groups of rules within a network composed of multiple switches. Let \(G\) represent a set of groups of rules, where \(R_i\) denotes the memory requirements of group \(i \in G\). Additionally, \(D\) defines a set of dependencies between groups. For each pair \((i, j) \in D\), where \(i, j \in G\), we say that group \(j\) depends on group \(i\), i.e. there's at least one rule in group \(i\) that forwards packets to group \(j\). The network also includes a set of switches \(S\), where each switch \(s \in S\) is characterized by a specific number of stages \(T_s\), and a memory capacity \(M_s\). Importantly, the memory capacity of each stage within the same switch is the same.

The goal is to find an optimal ordering of switches and groups of rules that satisfies the following constraints:

\begin{enumerate}
    \item \textbf{Exclusive Placement}: Each group of rules must be allocated to one and only one stage within a switch.
    
    \item \textbf{Memory Limit Compliance}: The total memory requirements of all groups in each stage must not exceed the stage's memory capacity (\(M_s\)).
    
    \item \textbf{Dependency Constraint}: For any pair \((i, j) \in D\), where \(i, j \in G\), group \(j\) cannot be placed in a switch occurring before the switch where group \(i\) is allocated. This restriction ensures there is no re-circulation between switches.
    
    \item \textbf{Minimized Re-circulations}: The overall number of re-circulations needs to be minimized to ensure optimal network performance.
\end{enumerate}