\subsection{Choice of Solver}

The Automatic Placement of Rulesets problem involves intricate dependencies and memory constraints. For this reason, choosing the right solver was critical to the project's success. We chose to formulate the problem as an SMT (Satisfiability Modulo Theories) instance because SMT solvers excel in managing complex logical constraints and optimizing problems. This approach allows us to express the problem's constraints and dependencies as a set of logical and arithmetic formulas, enabling the solver to efficiently explore and find solutions while considering the intricate nature of the problem.

SMT (Satisfiability Modulo Theories) is an extended version of the Boolean Satisfiability problem (SAT). In contrast to SAT, SMT is designed to handle problems involving not only pure Boolean logic but also rich theories, such as arithmetic, arrays, and bit-vectors. This makes SMT suitable for a wider range of real-world problems where SAT solvers may fall short due to the complexity of the constraints and dependencies involved. In optimization SMT problems, clauses can be classified into two categories:

\begin{enumerate}
    \item \textbf{Hard Clauses:} Mandatory constraints that must be satisfied for a solution to be valid. They represent non-negotiable requirements and ensure the fundamental feasibility of the solution. In our problem, all the constraints, except for the minimization of re-circulations, were considered hard clauses.

    \item \textbf{Soft Clauses:} Optional constraints that contribute to the optimization objective. They represent preferences or desires in the problem. Satisfying soft clauses enhances the solution's quality but is not obligatory for validity. The solver's job is to find an assignment that optimizes the total weight of satisfied soft clauses which, in our case, was the minimization of re-circulations.
\end{enumerate}

To conclude, SMT's ability to handle both mandatory and optimality constraints, makes it a suitable choice for complex problems like the Automatic Placement of Rulesets.

\subsection{Problem Encoding}

\subsubsection{Variables}

The first step in the formulation of the problem was to identify the variables that would be used to represent the problem's components. We decided to assign each individual stage in the network a unique identifier. This way, the placement of a group \(i\) in a stage with unique identifier \(j\) was represented by assigning the value $j$ to the variable \(group\_stage[i]\). Similarly, the placement of a group \(i\) in switch \(j\) was represented by assigning the value $j$ to the variable \(group\_switch[i]\). Both \(group\_stage\) and \(group\_switch\) arrays hold Z3's symbolic integers.

To encode the ordering of switches, we defined the boolean variable $switch\_behind[i][j]$. This variable is set to true when switch \(i\) is positioned behind switch \(j\).

Finally, we defined the integer variable, $stages\_memory[i][j]$ that holds a value of 0 when group \(j\) is in stage \(i\) or 1 otherwise. From our experiments, we found that not only did this variable help the solver find solutions faster, but it also perfomed the best when it was defined as an integer variable rather than a boolean one.

\subsubsection{Consistency Constraints}

To relate the different variables and to make sure that their values are kept consistent and meaningful, we formulated a set of consistency constraints. These constraints were formulated as hard clauses, ensuring the fundamental feasibility of the solution.

\begin{enumerate}
    \item \textbf{Relationship between \texttt{group\_stage} and \texttt{stages\_memory}:} For each pair of stage $st$, and group $gr$, the following clause was added:
    \begin{center}
        \(group\_stage[gr] == st \implies stages\_memory[st][gr] == 1\)
    \end{center}

    \item \textbf{No loops in \texttt{switch\_behind}:} To ensure that no loops were formed in the ordering of switches, the following clause was added:
    \begin{center}
        \(switch\_behind[s1][s2] \Leftrightarrow \neg switch\_behind[s2][s1]\)
    \end{center}

    \item \textbf{Transitive property in \texttt{switch\_behind}:} To ensure the transitive property was accounted for, for every permutation possible of every triple of switches $s1$, $s2$, $s3$ the following clause was added:
    \begin{center}
        \((switch\_behind[s1][s2] \cap switch\_behind[s2][s3]) \implies switch\_behind[s1][s3]\)
    \end{center}
\end{enumerate}

\subsubsection{Hard Constraints}

Below, we delineate the non-negotiable constraints that must be satisfied for a solution to be valid. These constraints were formulated as hard clauses, ensuring the fundamental feasibility of the solution.

\begin{enumerate}
    \item \textbf{Assignment Bounds:} Constraints were formulated to ensure that each group is assigned to a valid switch and stage. Thus, the following constrains were enforced:
    \begin{center}
        \(0 \leq group\_stage[i] \le N\_STAGES, \forall i \in $G$ \)
        
        \(0 \leq group\_switch[i] \le N\_SWITCHES, \forall i \in $G$ \)
    \end{center}

    \item \textbf{Memory Limit Compliance:} Constraints were devised to ensure that the total memory requirements of all groups within each stage did not exceed the stage's memory capacity. The constrains were the following for a stage $st$:
    \begin{center}
        \(\sum_{g=1}^{G} stages\_memory[st][g] * R_g \leq M_{st} \)
    \end{center}
    In straightforward terms, when a group occupies a stage, it incurs a memory requirement with a weight of one, thereby making a contribution towards reaching the memory limit of that stage. Note that $R_g$ is the memory requirements for group $g$ and $M_st$ is the memory capacity of stage $st$. Enforcing this constrains on all stages available achieves the desired goal.

    \item \textbf{Dependency Handling:} Dependencies between groups need to be handled in order to prevent re-circulations between switches. For each pair of groups \((g1, g2)\) where \(g1\) depends on \(g2\), specific conditions were established. Using the auxiliary variable $switch\_behind$ the constrains are pretty straightforward. For each pair of switches $s1$ and $s2$ and for every possible permutation of the switches' position, the constraint is:
    \begin{center}
        \(group\_switch[g1] == s1 \cap group\_switch[g2] == s2 \implies switch\_behind[s1][s2]  \)
        
    \end{center}
\end{enumerate}

\subsubsection{Soft Constraints}    

The only soft constraint in the problem was the minimization of re-circulations within a switch. We formulated the following clause for each pair of groups \((g1, g2)\) where \(g1\) depends on \(g2\):
\begin{center}
    \(\ group\_switch[g1] == group\_switch[g2] \implies group\_stage[g1] < group\_stage[g2]  \)
\end{center}

By encoding these constraints in this manner, we've effectively converted the problem into a set of boolean variables and logical connections, aligning with the capabilities of solvers such as Z3. The resulting formula encapsulates the core problem characteristics, empowering advanced solvers like Z3 to efficiently navigate the solution space.